//
//  main.swift
//  VM
//
//  Created by Drew Gottlieb on 12/14/15.
//  Copyright Â© 2015 Drew Gottlieb. All rights reserved.
//

import Foundation

enum MapError: ErrorType {
    case InvalidMapLine(line: String)
}

/// Maps a string from the format ".map LabelName, 1337;" to (1337, "LabelName")
///
/// The intended input for this is generated by assembler.swf in the right-most
/// textarea after assembling.
func parseMapLine(mapLine: String) throws -> (Int, String) {
    let parts: [String] = mapLine.componentsSeparatedByString(" ")
    
    guard parts.count == 3 else {
        throw MapError.InvalidMapLine(line: mapLine)
    }
    
    var label = parts[1]
    var address = parts[2]
    
    guard label.hasSuffix(",") && address.hasSuffix(";") else {
        throw MapError.InvalidMapLine(line: mapLine)
    }
    
    label.removeAtIndex(label.endIndex.predecessor())
    address.removeAtIndex(address.endIndex.predecessor())
    
    guard let addressValue = Int(address) else {
        throw MapError.InvalidMapLine(line: mapLine)
    }
    
    return (addressValue, label)
}

func loadFileContents(path: String) throws -> String {
    return try String(
        contentsOfFile: path).stringByTrimmingCharactersInSet(
            NSCharacterSet.whitespaceAndNewlineCharacterSet())
}

func parseMapFile(contents: String) throws -> [Int: String] {
    var mapDict = [Int: String]()
    for (k, v) in try contents.componentsSeparatedByString("\n").map(parseMapLine) {
        mapDict[k] = v
    }
    
    return mapDict
}

do {
    var mapDict = [Int: String]()
    
    let code = try loadFileContents(Process.arguments[1])
    
    // Optional second argument for referencing a map.txt, containing
    // the map output from assembler.swf.
    if Process.arguments.count > 2 {
        mapDict = try parseMapFile(try loadFileContents(Process.arguments[2]))
    }
    
    let cpu = try CPU(ram: code, map: mapDict)
    
    try cpu.execute() { cpu in
        print(cpu) // Uncomment this to print debugging info for every CPU cycle.
        return
    }    
} catch {
    print(error)
}


//
//  main.swift
//  VM
//
//  Created by Drew Gottlieb on 12/14/15.
//  Copyright Â© 2015 Drew Gottlieb. All rights reserved.
//

import Foundation

enum MapError: Error {
    case invalidMapLine(line: String)
}

/// Maps a string from the format ".map LabelName, 1337;" to (1337, "LabelName")
///
/// The intended input for this is generated by assembler.swf in the right-most
/// textarea after assembling.
func parseMapLine(_ mapLine: String) throws -> (Int, String) {
    let parts: [String] = mapLine.components(separatedBy: " ")
    
    guard parts.count == 3 else {
        throw MapError.invalidMapLine(line: mapLine)
    }
    
    var label = parts[1]
    var address = parts[2]
    
    guard label.hasSuffix(",") && address.hasSuffix(";") else {
        throw MapError.invalidMapLine(line: mapLine)
    }
    
    label.remove(at: label.characters.index(before: label.endIndex))
    address.remove(at: address.characters.index(before: address.endIndex))
    
    guard let addressValue = Int(address) else {
        throw MapError.invalidMapLine(line: mapLine)
    }
    
    return (addressValue, label)
}

func loadFileContents(_ path: String) throws -> String {
    return try String(
        contentsOfFile: path).trimmingCharacters(
            in: CharacterSet.whitespacesAndNewlines)
}

func parseMapFile(_ contents: String) throws -> [Int: String] {
    var mapDict = [Int: String]()
    for (k, v) in try contents.components(separatedBy: "\n").map(parseMapLine) {
        mapDict[k] = v
    }
    return mapDict
}

do {
    var mapDict = [Int: String]()
    
    let code = try loadFileContents(CommandLine.arguments[1])
    
    // Optional second argument for referencing a map.txt, containing
    // the map output from assembler.swf.
    if CommandLine.arguments.count > 2 {
        mapDict = try parseMapFile(try loadFileContents(CommandLine.arguments[2]))
    }
    
    let cpu = try CPU(ram: code, map: mapDict)
    
    cpu.registerInputHandler({
        return UInt16(getchar() & 0xFFFF)
    }, forAddress: 0x0FFF)
    
    cpu.registerOutputHandler({ word in
        putchar(Int32(word))
    }, forAddress: 0x0FFF)
    
    try cpu.execute() { cpu in
        // print(cpu) // Uncomment this to print debugging info for every CPU cycle.
        return
    }
} catch {
    print(error)
}

